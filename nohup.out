Loading required package: ParamHelpers
Loading required package: checkmate
Loading required package: BBmisc

Attaching package: ‘BBmisc’

The following object is masked from ‘package:emoa’:

    coalesce

The following object is masked from ‘package:base’:

    isFALSE


Attaching package: ‘mco’

The following objects are masked from ‘package:ecr’:

    normalizeFront, nsga2


Attaching package: ‘plotly’

The following object is masked from ‘package:ggplot2’:

    last_plot

The following object is masked from ‘package:ecr’:

    mutate

The following object is masked from ‘package:stats’:

    filter

The following object is masked from ‘package:graphics’:

    layout

[[1]]
[[1]]$value
function (Y, Yref) 
{
    igd <- sum(apply(Yref, 1, function(yref, Y) {
        min(apply(Y, 1, function(y, yref) {
            sqrt(sum((y - yref)^2))
        }, yref = yref))
    }, Y = Y))/nrow(Yref)
    return(igd)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (stopcrit, call.env) 
{
    assertthat::assert_that(all(unlist(lapply(call.env$stopcrit, 
        function(x) {
            assertthat::has_name(x, "name")
        }))))
    crits <- unlist(lapply(stopcrit, function(x) {
        x$name
    }))
    keep.running <- TRUE
    for (i in seq_along(crits)) {
        function_name <- paste0("stop_", tolower(crits[i]))
        keep.running <- keep.running & !do.call(function_name, 
            args = as.list(call.env))
    }
    return(keep.running)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (B, bigZ, bigV, ...) 
{
    assertthat::assert_that(identical(dim(bigZ), dim(bigV)))
    sel.indx <- t(apply(bigZ, MARGIN = 2, FUN = function(X) {
        unlist(as.matrix(sort.int(X, index.return = TRUE))[2])
    }))
    return(sel.indx)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (B, bigZ, bigV, beta, ...) 
{
    assertthat::assert_that(identical(dim(bigZ), dim(bigV)), 
        is.numeric(beta), beta >= 0)
    bigZV <- bigZ + beta * bigV
    sel.indx <- t(apply(bigZV, MARGIN = 2, FUN = order))
    return(sel.indx)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (bigZ, bigV, type = c("ts", "sr", "vt"), pf = NULL, 
    ...) 
{
    valid_types <- c("ts", "sr", "vt")
    assertthat::assert_that(identical(dim(bigZ), dim(bigV)), 
        type %in% valid_types)
    if (type == "sr") {
        assertthat::assert_that(is.numeric(pf), is_within(pf, 
            0, 1, strict = FALSE))
    }
    feasible <- (bigV == 0)
    cx <- switch(type, ts = (bigV > Inf), sr = (randM(bigV) <= 
        pf), vt = (bigV <= (colSums(feasible)/(nrow(bigV)^2)) * 
        colSums(bigV)))
    useF <- feasible | cx
    bigF <- bigZ
    bigI <- bigV
    bigF[!useF] <- NA
    bigI[useF] <- NA
    indxF <- t(apply(bigF, MARGIN = 2, FUN = order, na.last = TRUE))
    indxI <- t(apply(bigI, MARGIN = 2, FUN = order, na.last = FALSE))
    indx.joint <- t(sapply(1:ncol(bigZ), function(i) {
        (indxI[i, ] * !is.na(bigI[indxI[i, ], i])) + (indxF[i, 
            ] * !is.na(bigF[indxF[i, ], i]))
    }))
    return(indx.joint)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (N, problem, increments = NULL) 
{
    assertthat::assert_that(all(assertthat::has_name(problem, 
        c("xmax", "xmin", "m", "name"))), all(problem$xmin < 
        problem$xmax), identical(length(problem$xmax), length(problem$xmin)), 
        assertthat::is.count(N), assertthat::is.count(problem$m))
    if ("constraint" %in% names(problem)) {
        con <- problem$constraint
        assertthat::assert_that(assertthat::has_name(con, "name"))
    }
    prob.dim <- length(problem$xmax)
    if (is.null(increments) || is.null(increments$lhs)) {
        return(matrix(stats::runif(N * prob.dim), nrow = N))
    }
    else {
        return(lhs::randomLHS(N, prob.dim))
    }
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (decomp, ...) 
{
    assertthat::assert_that(assertthat::has_name(decomp, "H"), 
        length(decomp$H) > 1, all(sapply(decomp$H, assertthat::is.count)), 
        assertthat::has_name(decomp, "tau"), is_within(decomp$tau, 
            strict = c(TRUE, FALSE)), assertthat::are_equal(decomp$tau, 
            unique(decomp$tau)), assertthat::are_equal(length(decomp$H), 
            length(decomp$tau)), assertthat::has_name(decomp, 
            ".nobj"), assertthat::is.count(decomp$.nobj), decomp$.nobj >= 
            2)
    W <- mapply(decomp$H, decomp$tau, MoreArgs = list(decomp$.nobj), 
        FUN = function(h, t, nobj) {
            x = list(H = h, .nobj = nobj)
            l = decomposition_sld(x)
            l = l * t + (1 - t)/nobj
            return(l)
        })
    if (is.list(W)) {
        W <- do.call(rbind, W)
    }
    rownames(W) <- NULL
    return(W)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (decomp, ...) 
{
    assertthat::assert_that(assertthat::has_name(decomp, "H"), 
        assertthat::is.count(decomp$H), assertthat::has_name(decomp, 
            ".nobj"), assertthat::is.count(decomp$.nobj), decomp$.nobj >= 
            2)
    m <- decomp$.nobj
    H <- decomp$H
    N <- choose(H + m - 1, m - 1)
    W <- do.call(expand.grid, args = lapply(X = 1:(m - 1), FUN = function(X) {
        seq(0, H)/H
    }))
    W$VarLast <- 1 - rowSums(W)
    W <- as.matrix(subset(W, W$VarLast >= 0))
    rownames(W) <- NULL
    return(W)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (decomp, ...) 
{
    assertthat::assert_that(assertthat::has_name(decomp, "N"), 
        assertthat::is.count(decomp$N), assertthat::has_name(decomp, 
            ".nobj"), assertthat::is.count(decomp$.nobj), decomp$N >= 
            3)
    N <- decomp$N
    nf <- decomp$.nobj
    div <- which(sapply(seq_len(N), is_coprime, N))
    H <- t(utils::combn(x = div, m = nf - 1))
    construct_un <- function(h, N) {
        U <- t(sapply(seq_len(N), function(x) {
            (h * x)%%N
        }))
        U <- U + N * (1 - sign(U))
    }
    cd2 <- function(U) {
        magic <- (13/12)^ncol(U)
        S1 <- (2/nrow(U)) * sum(apply((1 + (abs(U - 0.5) - abs(U - 
            0.5)^2)/2), 1, prod))
        S2 <- (1/nrow(U)^2) * sum(sapply(1:nrow(U), function(y) {
            tU <- matrix(U[y, ], nrow = nrow(U), ncol = ncol(U), 
                byrow = TRUE)
            apply(1 + (abs(U - 0.5) + abs(tU - 0.5))/2 - abs(U - 
                tU)/2, MARGIN = 1, FUN = prod)
        }))
        return(magic - S1 + S2)
    }
    min_h <- H[which.min(apply(H, MARGIN = 1, FUN = function(x) {
        cd2(construct_un(x, N))
    })), ]
    Un <- (construct_un(min_h, N) - 0.5)/N
    if (nrow(Un) == 1) {
        Un <- t(Un)
    }
    U_pow <- t(t(Un)^sapply(seq_len(nf - 1), function(x) {
        (nf - x)^-1
    }))
    pow_prod <- t(apply(U_pow, MARGIN = 1, FUN = function(x) {
        sapply(seq_len(length(x)), FUN = function(y) {
            prod(x[seq_len(y - 1)])
        })
    }))
    if (nrow(pow_prod) == 1) {
        pow_prod <- t(pow_prod)
    }
    W <- (1 - U_pow) * pow_prod
    colnames(W) <- paste("Var", 1:ncol(W), sep = "")
    return(cbind(W, VarLast = apply(U_pow, MARGIN = 1, FUN = prod)))
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (neighbors, v.matrix, iter) 
{
    valid.methods <- c("lambda", "x")
    assertthat::assert_that(all(assertthat::has_name(neighbors, 
        c("name", "T"))), neighbors$name %in% valid.methods, 
        assertthat::is.count(neighbors$T), neighbors$T <= nrow(v.matrix), 
        is.numeric(neighbors$delta.p), length(neighbors$delta.p) == 
            1, is_within(neighbors$delta.p, 0, 1, strict = FALSE))
    if (iter == 1 || neighbors$name != "lambda") {
        BP <- list(B = NULL, P = NULL, fullB = NULL, fullP = NULL)
        BP$fullB <- cbind(1:nrow(v.matrix), FNN::get.knn(data = v.matrix, 
            k = nrow(v.matrix) - 1)$nn.index)
        BP$B.variation <- BP$fullB[, 1:neighbors$T]
        np <- nrow(v.matrix)
        if (np > neighbors$T) {
            BP$P <- matrix((1 - neighbors$delta.p)/(np - neighbors$T), 
                nrow = np, ncol = np)
            val <- neighbors$delta.p/neighbors$T
            BP$P <- do.call(rbind, lapply(1:np, FUN = function(i, 
                p, b, val) {
                p[i, b[i, ]] <- val
                p[i, ]
            }, p = BP$P, b = BP$B.variation, val = val))
        }
        else {
            BP$P <- matrix(1/np, nrow = np, ncol = np)
        }
        BP$fullP <- BP$P
        BP$fullP[, ] <- 1/ncol(BP$fullP)
    }
    else {
        call.env <- parent.frame()
        assertthat::assert_that("BP" %in% names(call.env))
        BP <- call.env$BP
    }
    BP$B.order <- BP$B.variation
    BP$B.scalarize <- BP$B.variation
    return(BP)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (X, problem, nfe, iter, cons = NULL) 
{
    assertthat::assert_that(is.matrix(X), is.numeric(X), ncol(X) == 
        length(problem$xmax), nfe == as.integer(nfe), nfe >= 
        0, iter == as.integer(iter), iter >= 0)
    X <- denormalize_population(X, problem)
    filename <- paste0("~/MOEADr/th_run/optimizer/interface/pop_vars_eval.txt")
    write.table(X, file = filename, row.names = FALSE, sep = "\t", 
        col.names = FALSE)
    old.wd <- getwd()
    setwd("~/MOEADr/th_run/optimizer/interface/")
    system("./moon_mop .")
    Y <- as.matrix(read.csv(paste0("pop_objs_eval.txt"), sep = "\t", 
        stringsAsFactors = F, header = F))
    setwd(old.wd)
    if ("constraints" %in% names(problem)) {
        old.wd <- getwd()
        setwd("~/MOEADr/th_run/optimizer/interface/")
        filename <- "pop_cons_eval.txt"
        cons <- as.matrix(read.csv(filename, sep = "\t", stringsAsFactors = F, 
            header = F))
        cons <- (-1) * cons
        cons <- scaling_Y(cons, cons)
        Vmatrix <- cons
        V <- list(Cmatrix = cons, Vmatrix = Vmatrix, v = rowSums(Vmatrix))
        setwd(old.wd)
    }
    else {
        V <- NULL
    }
    nfe <- nfe + nrow(X)
    R <- list(Y = Y, V = V, nfe = nfe, cons = cons)
    return(R)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (X, problem, nfe, cons = NULL) 
{
    assertthat::assert_that(is.matrix(X), is.numeric(X), ncol(X) == 
        length(problem$xmax), nfe == as.integer(nfe), nfe >= 
        0)
    X <- denormalize_population(X, problem)
    fun.args <- as.list(formals(problem$name))
    my.args <- sapply(names(fun.args), FUN = function(argname, 
        pars, args) {
        if (argname %in% names(pars)) {
            args[argname] <- pars[argname]
        }
        return(args[[argname]])
    }, pars = problem, args = fun.args, simplify = FALSE)
    my.args[[grep("[x|X]", names(my.args))]] <- X
    Y <- do.call(problem$name, args = my.args)
    if ("constraints" %in% names(problem)) {
        con <- problem$constraints
        if (is.null(con$epsilon)) 
            con$epsilon <- 0
        vfun.args <- as.list(formals(con$name))
        my.vargs <- sapply(names(vfun.args), FUN = function(argname, 
            pars, args) {
            if (argname %in% names(pars)) {
                args[argname] <- pars[argname]
            }
            return(args[[argname]])
        }, pars = con, args = vfun.args, simplify = FALSE)
        my.vargs[[grep("[x|X]", names(my.vargs))]] <- X
        V <- do.call(con$name, args = my.vargs)
    }
    else {
        V <- NULL
    }
    nfe <- nfe + nrow(X)
    R <- list(Y = Y, V = V, nfe = nfe, cons = cons)
    return(R)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (x) 
{
    x.shift <- x - seq_along(x) * 0.1
    sum((x.shift)^2 - 10 * cos(2 * pi * x.shift) + 10)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (Y) 
{
    idxDominators <- vector(mode = "list", nrow(Y))
    idxDominatees <- vector(mode = "list", nrow(Y))
    for (i in 1:(nrow(Y) - 1)) {
        for (j in i:nrow(Y)) {
            if (all(Y[i, ] <= Y[j, ]) && (Y[i, ] != Y[j, ])) {
                idxDominators[[j]] = c(idxDominators[[j]], i)
                idxDominatees[[i]] = c(idxDominatees[[i]], j)
            }
            else if (all(Y[j, ] <= Y[i, ]) && (Y[j, ] != Y[i, 
                ])) {
                idxDominators[[i]] = c(idxDominators[[i]], j)
                idxDominatees[[j]] = c(idxDominatees[[j]], i)
            }
        }
    }
    return(unlist(lapply(idxDominators, length)) == 0)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (decomp, m, ...) 
{
    assertthat::assert_that(assertthat::is.count(m), "name" %in% 
        names(decomp))
    decomp$.nobj <- m
    function_name <- paste0("decomposition_", tolower(decomp$name))
    W <- do.call(function_name, args = list(decomp = decomp))
    return(W)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function () 
{
    con.list <- ls("package:MOEADr")
    con.list <- con.list[grep(pattern = "constraint_", con.list)]
    con.list <- con.list[-which(con.list == "get_constraint_methods")]
    con.list.name <- gsub("constraint_", "", con.list)
    output <- data.frame(name = con.list.name, `More Info` = paste0("'?", 
        con.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function () 
{
    decomp.list <- ls("package:MOEADr")
    decomp.list <- decomp.list[grep(pattern = "decomposition_", 
        decomp.list)]
    decomp.list <- decomp.list[-which(decomp.list == "get_decomposition_methods")]
    decomp.list.name <- gsub("decomposition_", "", decomp.list)
    output <- data.frame(name = decomp.list.name, `More Info` = paste0("'?", 
        decomp.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function () 
{
    ls.list <- ls("package:MOEADr")
    ls.list <- ls.list[grep(pattern = "ls_", ls.list)]
    ls.list.name <- gsub("ls_", "", ls.list)
    output <- data.frame(type = ls.list.name, `More Info` = paste0("'?", 
        ls.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function () 
{
    scal.list <- ls("package:MOEADr")
    scal.list <- scal.list[grep(pattern = "scalarization_", scal.list)]
    scal.list <- scal.list[-which(scal.list == "get_scalarization_methods")]
    scal.list.name <- gsub("scalarization_", "", scal.list)
    output <- data.frame(name = scal.list.name, `More Info` = paste0("'?", 
        scal.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[19]]$visible
[1] FALSE


[[20]]
[[20]]$value
function () 
{
    stop.list <- ls("package:MOEADr")
    stop.list <- stop.list[grep(pattern = "stop_", stop.list)]
    stop.list <- stop.list[-which(stop.list == "get_stop_criteria")]
    stop.list <- stop.list[-which(stop.list == "check_stop_criteria")]
    stop.list.name <- gsub("stop_", "", stop.list)
    output <- data.frame(name = stop.list.name, `More Info` = paste0("'?", 
        stop.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[20]]$visible
[1] FALSE


[[21]]
[[21]]$value
function () 
{
    updt.list <- ls("package:MOEADr")
    updt.list <- updt.list[grep(pattern = "updt_", updt.list)]
    updt.list.name <- gsub("updt_", "", updt.list)
    output <- data.frame(name = updt.list.name, `More Info` = paste0("'?", 
        updt.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[21]]$visible
[1] FALSE


[[22]]
[[22]]$value
function () 
{
    var.list <- ls("package:MOEADr")
    var.list <- var.list[grep(pattern = "variation_", var.list)]
    var.list <- var.list[-which(var.list == "get_variation_operators")]
    var.list.name <- gsub("variation_", "", var.list)
    output <- data.frame(name = var.list.name, `More Info` = paste0("'?", 
        var.list, "'"))
    name.width <- max(sapply(as.character(output$More.Info), 
        nchar))
    names(output) <- format(names(output), width = name.width, 
        justify = "centre")
    format(output, width = name.width, justify = "centre")
}

[[22]]$visible
[1] FALSE


[[23]]
[[23]]$value
function (fun, dimensions, n.obj) 
{
    if (fun == "DTLZ1") {
        dtlz1 = makeDTLZ1Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz1
    }
    else if (fun == "DTLZ2") {
        dtlz2 = makeDTLZ2Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz2
    }
    else if (fun == "DTLZ3") {
        dtlz3 = makeDTLZ3Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz3
    }
    else if (fun == "DTLZ4") {
        dtlz4 = makeDTLZ4Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz4
    }
    else if (fun == "DTLZ5") {
        dtlz5 = makeDTLZ5Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz5
    }
    else if (fun == "DTLZ6") {
        dtlz6 = makeDTLZ6Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz6
    }
    else if (fun == "DTLZ7") {
        dtlz7 = makeDTLZ7Function(n.objectives = n.obj, dimensions = dimensions)
        problem.dtlz = dtlz7
    }
    out <- list(fn = problem.dtlz)
    return(out)
}

[[23]]$visible
[1] FALSE


[[24]]
[[24]]$value
function (fun, n.obj) 
{
    setwd("~/MOEADr/R/")
    fun.number <- as.numeric(strsplit(fun, "DTLZ")[[1]][2])
    if (fun.number == 1) {
        pareto.front <- read.csv(paste0("../DTLZ1.", n.obj, "D.pf"), 
            header = F, sep = "\t")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
        class(pareto.front[, 1])
    }
    else if (fun.number == 2) {
        pareto.front <- read.csv(paste0("../DTLZ2.", n.obj, "D.pf"), 
            header = F, sep = "\t")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun.number == 3) {
        if (n.obj == 2) {
            pareto.front <- read.csv(paste0("../DTLZ3.", n.obj, 
                "D.pf"), header = F, sep = "\t")
        }
        else {
            pareto.front <- read.csv(paste0("../DTLZ3.", n.obj, 
                "D.pf"), header = F, sep = " ")
        }
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun.number == 4) {
        if (n.obj == 2) {
            pareto.front <- read.csv(paste0("../DTLZ4.", n.obj, 
                "D.pf"), header = F, sep = "\t")
        }
        else {
            pareto.front <- read.csv(paste0("../DTLZ4.", n.obj, 
                "D.pf"), header = F, sep = " ")
        }
        pareto.front <- data.frame(pareto.front[, -c(n.obj + 
            1)])
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun.number == 5) {
        pareto.front <- read.csv(paste0("../DTLZ5.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun.number == 6) {
        pareto.front <- read.csv(paste0("../DTLZ6.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun.number == 7) {
        if (n.obj == 2) {
            pareto.front <- read.csv(paste0("../DTLZ7.", n.obj, 
                "D.pf"), header = F, sep = "\t")
        }
        else pareto.front <- read.csv(paste0("../DTLZ7.", n.obj, 
            "D.pf"), header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- data.matrix(pareto.front)
    }
    return(pareto.front)
}

[[24]]$visible
[1] FALSE


[[25]]
[[25]]$value
function (fun, d) 
{
    if (fun == "UF1") {
        uf1 = makeUFFunction(id = 1, dimensions = d)
        problem.uf = uf1
    }
    else if (fun == "UF2") {
        uf2 = makeUFFunction(id = 2, dimensions = d)
        problem.uf = uf2
    }
    else if (fun == "F3") {
        uf3 = makeUFFunction(id = 3, dimensions = d)
        problem.uf = uf3
    }
    else if (fun == "UF4") {
        uf4 = makeUFFunction(id = 4, dimensions = d)
        problem.uf = uf4
    }
    else if (fun == "UF5") {
        uf5 = makeUFFunction(id = 5, dimensions = d)
        problem.uf = uf5
    }
    else if (fun == "UF") {
        uf6 = makeUFFunction(id = 6, dimensions = d)
        problem.uf = uf6
    }
    else if (fun == "UF7") {
        uf7 = makeUFFunction(id = 7, dimensions = d)
        problem.uf = uf7
    }
    out <- list(fn = problem.uf)
    return(out)
}

[[25]]$visible
[1] FALSE


[[26]]
[[26]]$value
function (fun, n.obj, k, L) 
{
    if (fun == "WFG1") {
        wfg1 = makeWFG1Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg1
    }
    else if (fun == "WFG2") {
        wfg2 = makeWFG2Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg2
    }
    else if (fun == "WFG3") {
        wfg3 = makeWFG3Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg3
    }
    else if (fun == "WFG4") {
        wfg4 = makeWFG4Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg4
    }
    else if (fun == "WFG5") {
        wfg5 = makeWFG5Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg5
    }
    else if (fun == "WFG6") {
        wfg6 = makeWFG6Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg6
    }
    else if (fun == "WFG7") {
        wfg7 = makeWFG7Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg7
    }
    else if (fun == "WFG8") {
        wfg8 = makeWFG8Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg8
    }
    else if (fun == "WFG9") {
        wfg9 = makeWFG9Function(n.objectives = n.obj, k = k, 
            l = L)
        problem.wfg = wfg9
    }
    out <- list(fn = problem.wfg)
    return(out)
}

[[26]]$visible
[1] FALSE


[[27]]
[[27]]$value
function (fun, n.obj) 
{
    setwd("~/MOEADr/R/")
    if (fun == "WFG1") {
        print(paste0("../WFG1.", n.obj, "D.pf"))
        pareto.front <- read.csv(paste0("../WFG1.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG2") {
        if (n.obj == 2) {
            pareto.front <- read.csv(paste0("../WFG2.", n.obj, 
                "D.pf"), header = F, sep = "\t")
        }
        else {
            pareto.front <- read.csv(paste0("../WFG2.", n.obj, 
                "D.pf"), header = F, sep = " ")
        }
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG3") {
        pareto.front <- read.csv(paste0("../WFG3.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG4") {
        pareto.front <- read.csv(paste0("../WFG4.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG5") {
        pareto.front <- read.csv(paste0("../WFG5.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG6") {
        pareto.front <- read.csv(paste0("../WFG6.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG7") {
        pareto.front <- read.csv(paste0("../WFG7.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG8") {
        pareto.front <- read.csv(paste0("../WFG8.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    else if (fun == "WFG9") {
        pareto.front <- read.csv(paste0("../WFG9.", n.obj, "D.pf"), 
            header = F, sep = " ")
        pareto.front <- pareto.front[, -c(n.obj + 1)]
        pareto.front <- as.matrix(pareto.front)
    }
    return(pareto.front)
}

[[27]]$visible
[1] FALSE


[[28]]
[[28]]$value
function (Xt, Yt, Vt, B, W, which.x, trunc.x, problem, scaling, 
    aggfun, constraint, indexes, iter, my.file.n, ...) 
{
    print("ls_dvls")
    temp.Xt <- Xt
    temp.Yt <- Yt
    temp.W <- W
    Xt <- Xt[indexes, ]
    Yt <- Yt[indexes, ]
    Inds <- do.call(rbind, lapply(which(which.x), FUN = function(i, 
        B) {
        if (i < dimX[1]) {
            sample(x = B[i, ], size = 2, replace = FALSE)
        }
    }, B = B))
    nls <- nrow(Inds)
    ls.Phi <- matrix(stats::rnorm(nls, mean = 0.5, sd = 0.1), 
        nrow = nls, ncol = dimX[2], byrow = FALSE)
    dvls.B <- matrix(1:nls, ncol = 1)
    dvls.W <- W[which.x, , drop = FALSE]
    dvls.Xt <- Xt[which.x, , drop = FALSE]
    dvls.Xo <- dvls.Xt
    dvls.Yt <- Yt[which.x, , drop = FALSE]
    dvls.Vt <- Vt
    dvls.Vt$Cmatrix <- dvls.Vt$Cmatrix[which.x, , drop = FALSE]
    dvls.Vt$Vmatrix <- dvls.Vt$Vmatrix[which.x, , drop = FALSE]
    dvls.Vt$v <- dvls.Vt$v[which.x]
    W <- temp.W
    for (phi.m in c(-1, 1)) {
        dvls.X <- dvls.Xo + phi.m * ls.Phi * (Xt[Inds[, 1]] - 
            Xt[Inds[, 2]])
        if (trunc.x) 
            dvls.X <- matrix(pmax(0, pmin(dvls.X, 1)), nrow = nrow(dvls.X), 
                byrow = FALSE)
        dvls.YV <- evaluate_population(X = dvls.X, problem = problem, 
            nfe = 0, iter = iter, my.file.n = my.file.n)
        dvls.normYs <- scale_objectives(Y = dvls.YV$Y, Yt = dvls.Yt, 
            scaling = scaling)
        dvls.bigZ <- scalarize_values(normYs = dvls.normYs, W = dvls.W, 
            B = dvls.B, aggfun = aggfun)
        dvls.selin <- order_neighborhood(bigZ = dvls.bigZ, B = dvls.B, 
            V = dvls.YV$V, Vt = dvls.Vt, constraint = constraint)
        dvls.out <- updt_standard(X = dvls.X, Xt = dvls.Xt, Y = dvls.YV$Y, 
            Yt = dvls.Yt, V = dvls.YV$V, Vt = dvls.Vt, sel.indx = dvls.selin, 
            B = dvls.B)
        dvls.Xt <- dvls.out$X
        dvls.Yt <- dvls.out$Y
        dvls.Vt <- dvls.out$V
    }
    dvls.X <- NA * randM(Xt)
    dvls.X[which.x, ] <- dvls.Xt
    return(list(X = dvls.X, nfe = 2 * sum(which.x)))
}

[[28]]$visible
[1] FALSE


[[29]]
[[29]]$value
function (Xt, Yt, W, B, Vt, scaling, aggfun, constraint, epsilon = 1e-06, 
    which.x, ...) 
{
    assertthat::assert_that(is.numeric(epsilon), epsilon > 0)
    if (ncol(B) < 3) 
        stop("TPQA local search only works for neighbors$T > 3")
    tpqa.normYs <- scale_objectives(Y = Yt, Yt = Yt, scaling = scaling)
    tpqa.bigZ <- scalarize_values(normYs = tpqa.normYs, W = W, 
        B = B, aggfun = aggfun)
    tpqa.selind <- order_neighborhood(bigZ = tpqa.bigZ, B = B, 
        V = Vt, Vt = Vt, constraint = constraint)
    sels <- t(apply(tpqa.selind, MARGIN = 1, FUN = function(x, 
        ii) {
        x <- x[x != ii]
        return(x[1:3])
    }, ii = nrow(tpqa.bigZ)))
    Q <- (Xt[sels[, 2], , drop = FALSE] - Xt[sels[, 3], , drop = FALSE]) + 
        (Xt[sels[, 3], , drop = FALSE] - Xt[sels[, 1], , drop = FALSE]) * 
            2 + (Xt[sels[, 1], , drop = FALSE] - Xt[sels[, 2], 
        , drop = FALSE]) * 3
    Xhat <- ((Xt[sels[, 2], , drop = FALSE]^2 - Xt[sels[, 3], 
        , drop = FALSE]^2) + (Xt[sels[, 3], , drop = FALSE]^2 - 
        Xt[sels[, 1], , drop = FALSE]^2) * 2 + (Xt[sels[, 1], 
        , drop = FALSE]^2 - Xt[sels[, 2], , drop = FALSE]^2) * 
        3)/(2 * Q + 1e-16)
    Xls <- Xt[sels[, 1], , drop = FALSE] * (Q < epsilon) + Xhat * 
        (Q >= epsilon)
    Xls[!which.x, ] <- NA
    return(Xls)
}

[[29]]$visible
[1] FALSE


[[30]]
[[30]]$value
function (prob.name, ...) 
{
    if (!("smoof" %in% rownames(utils::installed.packages()))) {
        stop("Please install package 'smoof' to continue")
    }
    else {
        my.args <- as.list(sys.call())[-1]
        my.args$prob.name <- NULL
        if (length(my.args) == 0) 
            my.args <- list()
        myfun <- do.call(utils::getFromNamespace(x = paste0("make", 
            toupper(prob.name), "Function"), ns = "smoof"), args = my.args)
        myfun2 <- function(X, ...) {
            t(apply(X, MARGIN = 1, FUN = myfun))
        }
        return(myfun2)
    }
}

[[30]]$visible
[1] FALSE


[[31]]
[[31]]$value
function (preset = NULL, problem = NULL, decomp = NULL, aggfun = NULL, 
    neighbors = NULL, variation = NULL, update = NULL, constraint = NULL, 
    scaling = NULL, stopcrit = NULL, showpars = NULL, seed = NULL, 
    resource.allocation = NULL, ...) 
{
    moead.input.pars <- as.list(sys.call())[-1]
    if ("save.env" %in% names(moead.input.pars)) {
        if (moead.input.pars$save.env == TRUE) 
            saveRDS(as.list(environment()), "moead_env.rds")
    }
    if (!is.null(preset)) {
        if (is.null(problem)) 
            problem = preset$problem
        if (is.null(decomp)) 
            decomp = preset$decomp
        if (is.null(aggfun)) 
            aggfun = preset$aggfun
        if (is.null(neighbors)) 
            neighbors = preset$neighbors
        if (is.null(variation)) 
            variation = preset$variation
        if (is.null(update)) 
            update = preset$update
        if (is.null(scaling)) 
            scaling = preset$scaling
        if (is.null(stopcrit)) 
            stopcrit = preset$stopcrit
        if (is.null(resource.allocation)) 
            nullRA = TRUE
    }
    if (is.null(seed)) {
        if (!exists(".Random.seed")) 
            stats::runif(1)
        seed <- .Random.seed
    }
    else {
        assertthat::assert_that(assertthat::is.count(seed))
        set.seed(seed)
    }
    if (!is.null(resource.allocation)) {
        nullRA <- FALSE
    }
    nfe <- 0
    time.start <- Sys.time()
    iter.times <- numeric(10000)
    if (is.null(update$UseArchive)) {
        update$UseArchive <- FALSE
    }
    W <- generate_weights(decomp = decomp, m = problem$m)
    X <- create_population(N = nrow(W), problem = problem)
    if (problem$name == "problem.moon") {
        YV <- evaluate_population_moon(X = X, problem = problem, 
            nfe = nfe, iter = 0)
    }
    else {
        YV <- evaluate_population(X = X, problem = problem, nfe = nfe)
    }
    Y <- YV$Y
    V <- YV$V
    nfe <- YV$nfe
    indexes <- (1:dim(W)[1])
    Pi <- init_p(W, 1)
    if (!nullRA) {
        idx.bounday = NULL
        idx.tour = NULL
        if (resource.allocation$name == "GRA") 
            dt.bigZ <- list()
        if (resource.allocation$name == "DRA" && resource.allocation$selection == 
            "dra") {
            out <- calculate_DRA(resource.allocation, neighbors, 
                aggfun, X, W, Y, preset, problem)
            idx.bounday <- out$idx.bounday
            idx.tour <- out$idx.tour
            oldObj <- out$oldObj
        }
    }
    keep.running <- TRUE
    iter <- 0
    usage <- list(rep(1, dim(W)[1]))
    plot.resources <- list(rep(0, dim(W)[1]))
    plot.paretofront <- list(rep(0, dim(W)[1]))
    plot.paretoset <- list(rep(0, dim(W)[1]))
    while (keep.running) {
        iter <- iter + 1
        if ("save.iters" %in% names(moead.input.pars)) {
            if (moead.input.pars$save.iters == TRUE) 
                saveRDS(as.list(environment()), "moead_env.rds")
        }
        BP <- define_neighborhood(neighbors = neighbors, v.matrix = switch(neighbors$name, 
            lambda = W, x = X), iter = iter)
        Xt <- X
        Yt <- Y
        Vt <- V
        if (!nullRA) {
            out <- calc_idx(iter, resource.allocation, W, Pi, 
                X, Y, idx.bounday = idx.bounday, idx.tour = idx.bounday)
            indexes <- out$indexes
            temp.Y = out$temp.Y
            temp.X = out$temp.X
            Y = out$Y
            X = out$X
            iteration_usage = out$iteration_usage
        }
        B <- BP$B.variation[indexes, ]
        P <- BP$P[indexes, indexes]
        Xv <- do.call(perform_variation, args = as.list(environment()))
        X <- Xv$X
        ls.args <- Xv$ls.args
        nfe <- nfe + Xv$var.nfe
        if (problem$name == "problem.moon") {
            if (!nullRA) {
                temp.X[indexes, ] <- X
                X <- temp.X
            }
            YV <- evaluate_population_moon(X = X, problem = problem, 
                nfe = nfe, iter = iter)
            temp.X <- X
            X <- X[indexes, ]
        }
        else {
            YV <- evaluate_population(X = X, problem = problem, 
                nfe = nfe)
        }
        Y <- YV$Y
        V <- YV$V
        nfe <- YV$nfe
        if (!nullRA) {
            temp.X[indexes, ] <- X
            X <- temp.X
            if (problem$name != "problem.moon") {
                temp.Y[indexes, ] <- Y
                Y <- temp.Y
            }
        }
        normYs <- scale_objectives(Y = Y, Yt = Yt, scaling = scaling)
        B <- BP$B.scalarize
        bigZ <- scalarize_values(normYs = normYs, W = W, B = B, 
            aggfun = aggfun)
        B <- BP$B.order
        sel.indx <- order_neighborhood(bigZ = bigZ, B = B, V = V, 
            Vt = Vt, constraint = constraint)
        XY <- do.call(update_population, args = as.list(environment()))
        X <- XY$X
        Y <- XY$Y
        V <- XY$V
        Archive <- XY$Archive
        if (!nullRA) {
            if (resource.allocation$name == "DRA") {
                if (iter%%resource.allocation$dt == 0) {
                  newObj <- bigZ[neighbors$T + 1, ]
                  Pi <- dra(newObj, oldObj, Pi)
                  oldObj <- newObj
                }
            }
            if (resource.allocation$name == "GRA") {
                if (iter > resource.allocation$dt) {
                  index <- ((iter - 1)%%resource.allocation$dt) + 
                    1
                  Pi <- ONRA(dt.bigZ[[index]], bigZ, neighbors$T, 
                    epsilon = 1e-50)
                  dt.bigZ[[index]] <- bigZ
                }
                else {
                  dt.bigZ[[length(dt.bigZ) + 1]] <- bigZ
                }
            }
            if (resource.allocation$name == "RAD") {
                if (iter > resource.allocation$dt) {
                  diversity <- online_diversity(offspring = Y, 
                    parent = parent, W = W, old.dm = old.dm)
                  Pi <- diversity$p
                  old.dm <- diversity$dm
                }
                else old.dm <- init_p(W, 0)
                parent <- Y
            }
            if (resource.allocation$name == "norm") {
                if (iter > resource.allocation$dt) {
                  Pi <- by_norm(offspring_x = X, parent_x = parent)
                }
                if (resource.allocation$type == "inverse") {
                  Pi <- (-1) * Pi
                }
                parent <- X
            }
            if (resource.allocation$name == "random") {
                if (iter > resource.allocation$dt) {
                  Pi <- by_random(dim(W)[1])
                }
            }
        }
        if (nullRA) 
            usage[[length(usage) + 1]] <- rep(1, dim(W)[1])
        else usage[[length(usage) + 1]] <- as.integer(iteration_usage)
        paretofront <- cbind(Y, stage = iter, find_nondominated_points(Y))
        plot.paretofront <- rbind(plot.paretofront, paretofront)
        paretoset <- cbind(X, stage = iter)
        plot.paretoset <- rbind(plot.paretoset, paretoset)
        resources <- cbind(Reduce("+", usage), 1:dim(W)[1], stage = iter, 
            find_nondominated_points(Y))
        plot.resources <- rbind(plot.resources, resources)
        elapsed.time <- as.numeric(difftime(time1 = Sys.time(), 
            time2 = time.start, units = "secs"))
        iter.times[iter] <- ifelse(iter == 1, yes = as.numeric(elapsed.time), 
            no = as.numeric(elapsed.time) - sum(iter.times))
        keep.running <- check_stop_criteria(stopcrit = stopcrit, 
            call.env = environment())
        print_progress(iter.times, showpars)
    }
    X <- denormalize_population(X, problem)
    colnames(Y) <- paste0("f", 1:ncol(Y))
    colnames(W) <- paste0("f", 1:ncol(W))
    if (!is.null(Archive)) {
        Archive$X <- denormalize_population(Archive$X, problem)
        colnames(Archive$Y) <- paste0("f", 1:ncol(Archive$Y))
        Archive$W <- W
        colnames(Archive$W) <- paste0("f", 1:ncol(Archive$W))
    }
    colnames(plot.paretofront) <- c(paste0("f", 1:ncol(Y)), "stage", 
        "non-dominated")
    colnames(plot.paretoset) <- c(paste0("f", 1:ncol(X)), "stage")
    colnames(plot.resources) <- c("Resources", "Subproblem", 
        "stage", "non-dominated")
    out <- list(X = X, Y = Y, V = V, W = W, Archive = Archive, 
        ideal = apply(Y, 2, min), nadir = apply(Y, 2, max), nfe = nfe, 
        n.iter = iter, time = difftime(Sys.time(), time.start, 
            units = "secs"), seed = seed, inputConfig = moead.input.pars, 
        usage = usage, plot.paretofront = plot.paretofront, plot.paretoset = plot.paretoset, 
        plot.resources = plot.resources)
    class(out) <- c("moead", "list")
    return(out)
}

[[31]]$visible
[1] FALSE


[[32]]
[[32]]$value
function (neighbors, v.matrix, iter, parallel = NULL, cl = NULL, 
    ...) 
{
    BP <- list(B.variation = NULL, B.scalarize = NULL, B.order = NULL, 
        P = NULL, fullB = NULL, fullP = NULL)
    BP$fullB <- cbind(1:nrow(v.matrix), FNN::get.knn(data = v.matrix, 
        k = nrow(v.matrix) - 1)$nn.index)
    BP$B.variation <- BP$fullB[, 1:neighbors$T]
    BP$B.order <- BP$fullB[, 1:neighbors$LR]
    BP$B.scalarize <- BP$B.order
    np <- nrow(v.matrix)
    BP$P <- matrix((1 - neighbors$delta.p)/(np - neighbors$T), 
        nrow = np, ncol = np)
    val <- neighbors$delta.p/neighbors$T
    BP$P <- do.call(rbind, lapply(1:np, FUN = function(i, p, 
        b, val) {
        p[i, b[i, ]] <- val
        p[i, ]
    }, p = BP$P, b = BP$B, val = val))
    BP$fullP <- BP$P
    BP$fullP[, ] <- 1/ncol(BP$fullP)
    return(BP)
}

[[32]]$visible
[1] FALSE


[[33]]
[[33]]$value
function (bigZ, B, V, Vt, constraint) 
{
    assertthat::assert_that(nrow(bigZ) == ncol(B) + 1, ncol(bigZ) == 
        nrow(B))
    if (is.null(V)) {
        sel.indx <- t(apply(bigZ, MARGIN = 2, FUN = function(X) {
            unlist(as.matrix(sort.int(X, index.return = TRUE))[2])
        }))
    }
    else {
        bigV <- t(cbind(matrix(V$v[B], dim(B)), Vt$v))
        opname <- paste0("constraint_", constraint$name)
        ord.args <- constraint
        ord.args$name <- NULL
        ord.args$B <- B
        ord.args$bigZ <- bigZ
        ord.args$bigV <- bigV
        ord.args$V <- V
        ord.args$Vt <- Vt
        sel.indx <- do.call(opname, args = ord.args)
    }
    return(sel.indx)
}

[[33]]$visible
[1] FALSE


[[34]]
[[34]]$value
function (variation, X, iter, ...) 
{
    var.input.pars <- as.list(sys.call())[-1]
    .ignore <- lapply(variation, FUN = function(x) {
        assertthat::assert_that(assertthat::has_name(x, "name"))
    })
    lsi <- which(sapply(variation, FUN = function(x) {
        x$name
    }) == "localsearch")
    if (length(lsi) == 0) {
        ls.args <- NULL
        variation.nols <- variation
    }
    else {
        if ("ls.args" %in% names(var.input.pars)) {
            ls.args <- var.input.pars$ls.args
        }
        else {
            ls.args <- variation[[lsi]]
            valid.types <- gsub(" ", "", get_localsearch_methods()[, 
                1])
            assertthat::assert_that(!is.null(ls.args$tau.ls) | 
                !is.null(ls.args$gamma.ls))
            if (is.null(ls.args$tau.ls)) 
                ls.args$tau.ls <- 1e+09
            if (is.null(ls.args$gamma.ls)) 
                ls.args$gamma.ls <- 0
            if (is.null(ls.args$unsync)) 
                ls.args$unsync <- TRUE
            if (is.null(ls.args$trunc.x)) 
                ls.args$trunc.x <- TRUE
            assertthat::assert_that("iter" %in% names(var.input.pars), 
                ls.args$type %in% valid.types, assertthat::is.count(ls.args$tau.ls), 
                is_within(ls.args$gamma.ls, 0, 1, strict = FALSE), 
                is.logical(ls.args$unsync), is.logical(ls.args$trunc.x))
        }
        if (iter == 1) {
            if (ls.args$unsync && ls.args$tau.ls < 1e+09) {
                first.ls <- sample.int(n = ls.args$tau.ls - 1, 
                  size = nrow(X), replace = TRUE)
            }
            else first.ls <- rep(ls.args$tau.ls, times = nrow(X))
            ls.args$name <- NULL
            ls.args$first.ls <- first.ls
        }
        variation.nols <- variation[-lsi]
    }
    var.nfe <- 0
    X <- var.input.pars$X
    var.input.pars$X <- NULL
    for (i in seq_along(variation.nols)) {
        opname <- paste0("variation_", variation.nols[[i]]$name)
        var.args <- c(var.input.pars, variation.nols[[i]], list(X = X))
        X <- do.call(opname, args = var.args)
        if (is.list(X)) {
            var.nfe <- var.nfe + X$nfe
            X <- X$X
        }
    }
    if (length(lsi) > 0) {
        which.tau <- ((iter + ls.args$first.ls[ls.args$indexes] - 
            1)%%ls.args$tau.ls == 0)
        which.gamma <- stats::runif(nrow(X)) <= rep(ls.args$gamma.ls, 
            times = nrow(X))
        which.x <- (which.tau | which.gamma) & (iter != 1)
        if (any(which.x)) {
            ls.args2 <- c(var.input.pars, ls.args, var.input.pars$iter)
            ls.args2$which.x <- which.x
            Xls <- do.call("variation_localsearch", args = ls.args2)
            if (is.list(Xls)) {
                var.nfe <- var.nfe + Xls$nfe
                Xls <- Xls$X
            }
            X[which.x, ] <- Xls[which.x, ]
        }
    }
    return(list(X = X, ls.args = ls.args, var.nfe = var.nfe))
}

[[34]]$visible
[1] FALSE


[[35]]
[[35]]$value
function (x, ..., useArchive = FALSE, feasible.only = TRUE, viol.threshold = 1e-06, 
    nondominated.only = TRUE, plot.weights = FALSE, which.objectives = NULL, 
    suppress.pause = FALSE, color.by.obj = 1) 
{
    assertthat::assert_that("moead" %in% class(x), is.logical(useArchive), 
        is.logical(feasible.only), is.logical(nondominated.only), 
        is.logical(plot.weights), is.numeric(viol.threshold) && 
            viol.threshold >= 0, is.numeric(color.by.obj), color.by.obj %in% 
            seq(1, ncol(x$Y)), is.null(which.objectives) || all(which.objectives > 
            0), is.null(which.objectives) || all(which.objectives == 
            round(which.objectives)))
    Y <- x$Y
    X <- x$X
    V <- x$V
    W <- x$W
    if (useArchive && !is.null(x$Archive)) {
        Y <- x$Archive$Y
        X <- x$Archive$X
        V <- x$Archive$V
    }
    if (nondominated.only) {
        nd.indx <- find_nondominated_points(Y)
        Y <- Y[nd.indx, ]
        X <- X[nd.indx, ]
        if (!is.null(V)) {
            V$Cmatrix <- V$Cmatrix[nd.indx, ]
            V$Vmatrix <- V$Vmatrix[nd.indx, ]
            V$v <- V$v[nd.indx]
        }
    }
    if (!is.null(which.objectives)) {
        Y <- Y[, which.objectives]
        W <- W[, which.objectives]
    }
    ideal <- apply(Y, 2, min)
    nadir <- apply(Y, 2, max)
    nobj <- ncol(Y)
    if (nobj == 2) {
        grDevices::dev.hold()
        graphics::plot(Y[, 1], Y[, 2], type = "p", xlab = colnames(Y)[1], 
            ylab = colnames(Y)[2], pch = 16, main = "Objectives plot", 
            las = 1)
        if (plot.weights) {
            for (i in 1:nrow(W)) {
                termpt <- 1.1 * W[i, ] * (nadir - ideal)
                graphics::points(x = c(ideal[1], termpt[1]), 
                  y = c(ideal[2], termpt[2]), type = "l", lwd = 0.5)
            }
        }
        grDevices::dev.flush()
        if (!suppress.pause) 
            invisible(readline(prompt = "Press [enter] to continue"))
    }
    if (nobj == 3) {
        if ("scatterplot3d" %in% rownames(utils::installed.packages())) {
            grDevices::dev.hold()
            s3d <- scatterplot3d::scatterplot3d(Y, pch = 20, 
                main = "Objectives plot", las = 1)
            if (plot.weights) {
                for (i in 1:nrow(W)) {
                  termpt <- 1.1 * W[i, ] * (nadir - ideal)
                  s3d$points3d(x = c(ideal[1], termpt[1]), y = c(ideal[2], 
                    termpt[2]), z = c(ideal[3], termpt[3]), type = "l", 
                    lwd = 0.5)
                }
            }
            grDevices::dev.flush()
            if (!suppress.pause) 
                invisible(readline(prompt = "Press [enter] to continue"))
        }
        else {
            cat("Please install package 'scatterplot3d' to generate scatter plot.")
        }
    }
    if (nobj > 2) {
        if ("MASS" %in% rownames(utils::installed.packages())) {
            grDevices::dev.hold()
            rbPal <- grDevices::colorRampPalette(c("green", "purple"))
            cols <- rbPal(nrow(Y))
            MASS::parcoord(Y[order(Y[, color.by.obj]), ], lwd = 0.6, 
                var.label = TRUE, col = cols, main = "Parallel coordinates plot", 
                las = 1)
            grDevices::dev.flush()
            if (!suppress.pause) 
                invisible(readline(prompt = "Press [enter] to continue"))
        }
        else {
            cat("Please install package 'MASS' to generate parallel coordinates plot.")
        }
        grDevices::dev.hold()
        graphics::pairs(Y, upper.panel = NULL, pch = 20, main = "2-objective projections")
        grDevices::dev.flush()
    }
    if (!suppress.pause) 
        invisible()
}

[[35]]$visible
[1] FALSE


[[36]]
[[36]]$value
function (name = NULL) 
{
    original <- list(description = "Original MOEA/D: Zhang and Li (2007) (sec. V-E, p.721-722)", 
        decomp = list(name = "SLD", H = 99), neighbors = list(name = "lambda", 
            T = 20, delta.p = 1), aggfun = list(name = "wt"), 
        variation = list(list(name = "sbx", etax = 20, pc = 1), 
            list(name = "polymut", etam = 20, pm = 0.1), list(name = "truncate")), 
        update = list(name = "standard", UseArchive = FALSE), 
        scaling = list(name = "none"), constraint = list(name = "none"), 
        stopcrit = list(list(name = "maxiter", maxiter = 200)))
    original <- list(description = "Original MOEA/D: Zhang and Li (2007), Sec. V-E, p.721-722", 
        decomp = list(name = "SLD", H = 99), neighbors = list(name = "lambda", 
            T = 20, delta.p = 1), aggfun = list(name = "wt"), 
        variation = list(list(name = "sbx", etax = 20, pc = 1), 
            list(name = "polymut", etam = 20, pm = 0.1), list(name = "truncate")), 
        update = list(name = "standard", UseArchive = FALSE), 
        scaling = list(name = "none"), constraint = list(name = "none"), 
        stopcrit = list(list(name = "maxiter", maxiter = 200)))
    original2 <- list(description = "Original MOEA/D, v2: Zhang and Li (2007), Sec. V-F, p.724", 
        decomp = list(name = "SLD", H = 99), neighbors = list(name = "lambda", 
            T = 20, delta.p = 1), aggfun = list(name = "PBI", 
            theta = 5), variation = list(list(name = "sbx", etax = 20, 
            pc = 1), list(name = "polymut", etam = 20, pm = 0.1), 
            list(name = "truncate")), update = list(name = "standard", 
            UseArchive = FALSE), scaling = list(name = "simple"), 
        constraint = list(name = "none"), stopcrit = list(list(name = "maxiter", 
            maxiter = 200)))
    moead.de <- list(description = "MOEA/D-DE: Li and Zhang (2009)", 
        decomp = list(name = "SLD", H = 299), neighbors = list(name = "lambda", 
            T = 20, delta.p = 0.9), aggfun = list(name = "wt"), 
        variation = list(list(name = "diffmut", basis = "rand", 
            phi = 0.5), list(name = "polymut", etam = 20, pm = 1/30), 
            list(name = "truncate")), update = list(name = "restricted", 
            nr = 2, UseArchive = FALSE), scaling = list(name = "none"), 
        constraint = list(name = "none"), stopcrit = list(list(name = "maxiter", 
            maxiter = 300)))
    var.names <- names(as.list(environment()))
    var.names <- var.names[(length(var.names) - 1):1]
    if (is.null(name)) {
        descriptions <- unlist(lapply(X = var.names, FUN = function(x) {
            get(x)$description
        }))
        output <- data.frame(name = var.names, x = rep("|", length(var.names)), 
            description = descriptions)
        print(format(output, justify = "left"))
        cat("\n\nUse preset_moead(\"name\") to generate a standard MOEAD composition\n\n")
        invisible(TRUE)
    }
    else {
        if (name %in% var.names) {
            preset <- get(name)
            preset$description <- NULL
            return(preset)
        }
        else stop("Preset ", name, "not defined.")
    }
}

[[36]]$visible
[1] FALSE


[[37]]
[[37]]$value
function (x, ...) 
{
    assertthat::assert_that("moead" %in% class(x))
    cat("\nInput Configuration:\n")
    print(x$inputConfig)
    cat("\n#====================================")
    cat("\nTotal iterations: ", x$n.iter)
    cat("\nPopulation size: ", nrow(x$X))
    cat("\nEstimated ideal point: [", x$ideal, "]")
    cat("\nEstimated nadir point: [", x$nadir, "]")
    cat("\n#====================================")
}

[[37]]$visible
[1] FALSE


[[38]]
[[38]]$value
function (iter.times, showpars) 
{
    if (!any("show.iters" == names(showpars))) 
        showpars$show.iters <- "numbers"
    if (!any("showevery" == names(showpars))) 
        showpars$showevery <- 10
    iter <- sum(iter.times != 0)
    assertthat::assert_that(assertthat::is.count(showpars$showevery), 
        length(showpars$show.iters) == 1, showpars$show.iters %in% 
            c("dots", "numbers", "none"), length(showpars$showevery) == 
            1)
    if (showpars$show.iters != "none") {
        if (iter == 1) 
            cat("\nMOEA/D running: ")
        if (iter%%showpars$showevery == 0) {
            if (showpars$show.iters == "dots") 
                cat(".")
            if (showpars$show.iters == "numbers") 
                cat("\nIteration:", iter, " | Elapsed time:", 
                  iter.times[iter], "seconds")
        }
    }
}

[[38]]$visible
[1] FALSE


[[39]]
[[39]]$value
function (iter, resource.allocation, W, Pi, X, Y, idx.bounday = NULL, 
    idx.tour = NULL) 
{
    rand.seq <- init_p(W, 1)
    indexes <- 1:dim(W)[1]
    iteration_usage <- rep(1, dim(W)[1])
    if (iter > resource.allocation$dt) {
        if (resource.allocation$selection == "dra") {
            size <- floor(dim(W)[1]/5) - problem$m
            idx.tour <- selTournament(fitness = -Pi, n.select = size, 
                k = 10)
            indexes <- append(idx.bounday, idx.tour)
            iteration_usage[!indexes] <- 0
        }
        else if (resource.allocation$selection == "random") {
            rand.seq <- runif(length(Pi))
            indexes <- which(rand.seq <= Pi)
            if (length(indexes) < 3 || is.null(length(indexes))) {
                indexes <- which(rand.seq <= 1)
            }
            iteration_usage <- (rand.seq <= Pi)
        }
        else if (resource.allocation$selection == "tour") {
            found <- 0
            size <- ceiling(dim(W)[1] * resource.allocation$size)
            k <- ceiling(dim(W)[1] * resource.allocation$k)
            indexes <- vector(length = size)
            temp.idx <- !vector(length = size)
            while (TRUE) {
                indexes[temp.idx] <- selTournament(fitness = -Pi, 
                  n.select = size - found, k = k)
                if (length(unique(indexes)) == length(indexes)) {
                  break
                }
                else {
                  temp.idx <- !unique(indexes)
                  indexes <- unique(indexes)
                  found <- found + length(indexes)
                }
            }
            iteration_usage[!indexes] <- 0
        }
    }
    temp.X <- X
    X <- X[indexes, ]
    temp.Y <- Y
    Y <- Y[indexes, ]
    out <- list(indexes = indexes, temp.Y = temp.Y, temp.X = temp.X, 
        Y = Y, X = X, iteration_usage = iteration_usage)
    return(out)
}

[[39]]$visible
[1] FALSE


[[40]]
[[40]]$value
function (algo_conf, algo) 
{
    if (algo == "original") {
        if (is.null(algo_conf$neighbors)) {
            algo_conf$neighbors <- algo_conf$preset$neighbors
            algo_conf$neighbors$T = sample(10:20, 1)
            algo_conf$neighbors$delta.p = runif(1)
        }
        else {
            algo_conf$neighbors$T = sample(10:20, 1)
            algo_conf$neighbors$delta.p = runif(1)
        }
        if (is.null(algo_conf$variation)) {
            algo_conf$variation <- algo_conf$preset$variation
            algo_conf$variation[[1]]$etax <- sample(1:100, 1)
            algo_conf$variation[[1]]$pc <- runif(1)
            algo_conf$variation[[2]]$etam <- sample(1:100, 1)
            algo_conf$variation[[2]]$pm <- runif(1)
        }
        else {
            algo_conf$variation <- algo_conf$preset$variation
            algo_conf$variation[[1]]$etax <- sample(1:100, 1)
            algo_conf$variation[[1]]$pc <- runif(1)
            algo_conf$variation[[2]]$etam <- sample(1:100, 1)
            algo_conf$variation[[2]]$pm <- runif(1)
        }
        algo_conf$UseArchive <- sample(0:1, 1)
        if (is.null(algo_conf$update)) {
            algo_conf$update <- algo_conf$preset$update
            algo_conf$update$nr <- sample(1:10, 1)
        }
        else {
            algo_conf$update$nr <- sample(1:10, 1)
        }
    }
    else {
        if (is.null(algo_conf$neighbors)) {
            algo_conf$neighbors <- algo_conf$preset$neighbors
            algo_conf$neighbors$T = sample(10:20, 1)
            algo_conf$neighbors$delta.p = runif(1)
        }
        else {
            algo_conf$neighbors$T = sample(10:20, 1)
            algo_conf$neighbors$delta.p = runif(1)
        }
        if (is.null(algo_conf$variation)) {
            algo_conf$variation <- algo_conf$preset$variation
            algo_conf$variation[[1]]$phi <- runif(1)
            algo_conf$variation[[2]]$etam <- sample(1:100, 1)
            algo_conf$variation[[2]]$pm <- runif(1)
        }
        else {
            algo_conf$variation <- algo_conf$preset$variation
            algo_conf$variation[[1]]$phi <- runif(1)
            algo_conf$variation[[2]]$etam <- sample(1:100, 1)
            algo_conf$variation[[2]]$pm <- runif(1)
        }
        algo_conf$UseArchive <- sample(0:1, 1)
        if (is.null(algo_conf$update)) {
            algo_conf$update <- algo_conf$preset$update
            algo_conf$update$nr <- sample(1:10, 1)
        }
        else {
            algo_conf$update$nr <- sample(1:10, 1)
        }
    }
    return(algo_conf)
}

[[40]]$visible
[1] FALSE


[[41]]
[[41]]$value
function (X, epsilon = 0, ...) 
{
    Cmatrix <- matrix(numeric(), nrow = nrow(X), ncol = 1)
    colnames(Cmatrix) <- "sum(x)-1"
    Cmatrix[, 1] <- rowSums(X) - 1
    Vmatrix <- pmax(abs(Cmatrix) - epsilon, 0)
    return(list(Cmatrix = Cmatrix, Vmatrix = Vmatrix, v = rowSums(Vmatrix)))
}

[[41]]$visible
[1] FALSE


[[42]]
[[42]]$value
function (Y, W, minP, eps = 1e-16, ...) 
{
    assertthat::assert_that(is.matrix(Y) && is.matrix(W), identical(dim(W), 
        dim(Y)), length(minP) == ncol(Y))
    minP <- matrix(minP, nrow = nrow(Y), ncol = ncol(Y), byrow = TRUE)
    Rho <- (W + eps)^(-1)/rowSums((W + eps)^(-1))
    Z <- apply(Rho * (Y - minP + eps), MARGIN = 1, FUN = max)
    return(as.numeric(Z))
}

[[42]]$visible
[1] FALSE


[[43]]
[[43]]$value
function (Y, W, maxP, aggfun, eps = 1e-16, ...) 
{
    assertthat::assert_that(is.matrix(Y) && is.matrix(W), identical(dim(W), 
        dim(Y)), assertthat::has_name(aggfun, "theta"), length(maxP) == 
        ncol(Y))
    maxP <- matrix(maxP, nrow = nrow(Y), ncol = ncol(Y), byrow = TRUE)
    NormW <- matrix(sqrt(rowSums(W^2)), nrow = nrow(W), ncol = ncol(W), 
        byrow = FALSE)
    D1 <- matrix(abs(rowSums((maxP - Y) * W))/NormW[, 1], nrow = nrow(W), 
        ncol = ncol(W), byrow = FALSE)
    D2 <- sqrt(rowSums(((maxP - Y) - D1 * W/NormW)^2))
    return(aggfun$theta * as.numeric(D2) - as.numeric(D1[, 1]))
}

[[43]]$visible
[1] FALSE


[[44]]
[[44]]$value
function (Y, W, minP, aggfun, eps = 1e-16, ...) 
{
    assertthat::assert_that(is.matrix(Y) && is.matrix(W), identical(dim(W), 
        dim(Y)), assertthat::has_name(aggfun, "theta"), length(minP) == 
        ncol(Y))
    minP <- matrix(minP, nrow = nrow(Y), ncol = ncol(Y), byrow = TRUE)
    NormW <- matrix(sqrt(rowSums(W^2)), nrow = nrow(W), ncol = ncol(W), 
        byrow = FALSE)
    D1 <- matrix(rowSums((Y - minP + eps) * W)/NormW, nrow = nrow(W), 
        ncol = ncol(W), byrow = FALSE)
    D2 <- sqrt(rowSums((Y - minP - D1 * W/NormW)^2))
    return(as.numeric(D1[, 1] + aggfun$theta * D2))
}

[[44]]$visible
[1] FALSE


[[45]]
[[45]]$value
function (Y, W, minP, eps = 1e-16, ...) 
{
    assertthat::assert_that(is.matrix(Y) && is.matrix(W), identical(dim(W), 
        dim(Y)), length(minP) == ncol(Y))
    minP <- matrix(minP, nrow = nrow(Y), ncol = ncol(Y), byrow = TRUE)
    Z <- apply(W * (Y - minP), MARGIN = 1, FUN = sum)
    return(as.numeric(Z))
}

[[45]]$visible
[1] FALSE


[[46]]
[[46]]$value
function (Y, W, minP, eps = 1e-16, ...) 
{
    assertthat::assert_that(is.matrix(Y) && is.matrix(W), identical(dim(W), 
        dim(Y)), length(minP) == ncol(Y))
    minP <- matrix(minP, nrow = nrow(Y), ncol = ncol(Y), byrow = TRUE)
    Z <- apply(W * (Y - minP + eps), MARGIN = 1, FUN = max)
    return(as.numeric(Z))
}

[[46]]$visible
[1] FALSE


[[47]]
[[47]]$value
function (normYs, W, B, aggfun) 
{
    assertthat::assert_that(is.matrix(normYs$Y), is.numeric(normYs$Y), 
        is.matrix(normYs$Yt), is.numeric(normYs$Yt), identical(dim(normYs$Y), 
            dim(normYs$Yt)), is.matrix(B), is.numeric(B), all(B == 
            as.integer(B)), nrow(normYs$Y) == nrow(B), is.numeric(normYs$minP), 
        is.numeric(normYs$maxP), length(normYs$minP) == length(normYs$maxP))
    bigY <- normYs$Y[as.vector(t(B)), , drop = FALSE]
    bigW <- W[rep(1:nrow(W), each = ncol(B)), , drop = FALSE]
    bigZ <- matrix(numeric(), ncol = nrow(B), nrow = ncol(B) + 
        1)
    function_name <- paste0("scalarization_", tolower(aggfun$name))
    bigZ[1:ncol(B), ] <- matrix(do.call(function_name, args = list(Y = bigY, 
        W = bigW, aggfun = aggfun, minP = normYs$minP, maxP = normYs$maxP)), 
        ncol = nrow(W), byrow = FALSE)
    bigZ[nrow(bigZ), ] <- do.call(function_name, args = list(Y = normYs$Yt, 
        W = W, aggfun = aggfun, minP = normYs$minP, maxP = normYs$maxP))
    return(bigZ)
}

[[47]]$visible
[1] FALSE


[[48]]
[[48]]$value
function (Y, Yt, scaling, eps = 1e-16, ...) 
{
    assertthat::assert_that("name" %in% names(scaling), is.matrix(Y) & 
        is.matrix(Yt), identical(dim(Y), dim(Yt)))
    minP <- getminP(rbind(Y, Yt))
    maxP <- getmaxP(rbind(Y, Yt))
    if (scaling$name == "none") {
        return(list(Y = Y, Yt = Yt, minP = minP, maxP = maxP))
    }
    if (scaling$name == "simple") {
        MinP <- matrix(rep(minP, times = nrow(Y)), nrow = nrow(Y), 
            byrow = TRUE)
        MaxP <- matrix(rep(maxP, times = nrow(Y)), nrow = nrow(Y), 
            byrow = TRUE)
        Y <- (Y - MinP)/(MaxP - MinP + eps)
        Yt <- (Yt - MinP)/(MaxP - MinP + eps)
        minP <- 0 * minP
        maxP <- minP + 1
        return(list(Y = Y, Yt = Yt, minP = minP, maxP = maxP))
    }
}

[[48]]$visible
[1] FALSE


[[49]]
[[49]]$value
function (stopcrit, nfe, ...) 
{
    maxeval.i <- which(sapply(stopcrit, function(x) x$name) == 
        "maxeval")
    maxeval <- stopcrit[[maxeval.i]]$maxeval
    assertthat::assert_that(assertthat::is.count(maxeval))
    return(nfe >= maxeval)
}

[[49]]$visible
[1] FALSE


[[50]]
[[50]]$value
function (stopcrit, iter, ...) 
{
    maxiter.i <- which(sapply(stopcrit, function(x) x$name) == 
        "maxiter")
    maxiter <- stopcrit[[maxiter.i]]$maxiter
    assertthat::assert_that(assertthat::is.count(maxiter))
    return(iter >= maxiter)
}

[[50]]$visible
[1] FALSE


[[51]]
[[51]]$value
function (stopcrit, iter.times, ...) 
{
    t.pars <- stopcrit[[which(sapply(stopcrit, function(x) x$name) == 
        "maxtime")]]
    assertthat::assert_that(is.numeric(t.pars$maxtime), t.pars$maxtime > 
        0)
    elapsed.time <- sum(iter.times)
    mean.iter.time <- mean(iter.times)
    return(elapsed.time + mean.iter.time >= t.pars$maxtime)
}

[[51]]$visible
[1] FALSE


[[52]]
[[52]]$value
function (object, ..., scaling.reference = NULL, useArchive = FALSE, 
    viol.threshold = 1e-06, ndigits = 3, ref.point = NULL, ref.front = NULL, 
    show.output = NULL) 
{
    nullRP <- is.null(ref.point)
    nullRF <- is.null(ref.front)
    nullShowOutput <- is.null(show.output)
    assertthat::assert_that("moead" %in% class(object), is.logical(useArchive), 
        is.numeric(viol.threshold) && viol.threshold >= 0, assertthat::is.count(ndigits), 
        nullRP || is.numeric(ref.point), nullRP || length(ref.point) == 
            ncol(object$Y), nullRF || is.numeric(ref.front), 
        nullRF || ncol(ref.front) == ncol(object$Y))
    if (useArchive && !is.null(object$Archive)) {
        Y <- object$Archive$Y
        V <- object$Archive$V
    }
    else {
        Y <- object$Y
        V <- object$V
    }
    hv.scaled <- 0
    igd <- 0
    feas.idx <- rep(TRUE, nrow(Y))
    if (!is.null(V)) 
        feas.idx <- (rowSums(V$Vmatrix > viol.threshold) == 0)
    npts <- nrow(Y)
    nfeas <- sum(feas.idx)
    nndom <- sum(find_nondominated_points(Y[feas.idx, ]))
    ideal.est <- apply(Y[feas.idx, ], 2, min)
    nadir.est <- apply(Y[feas.idx, ], 2, max)
    if (!nullRF) 
        igd <- calcIGD(Y, Yref = ref.front)
    if ("emoa" %in% rownames(utils::installed.packages())) {
        if (nullRP) {
            cat("Warning: reference point not provided:\n\n          using the maximum in each dimension instead.")
            ref.point <- nadir.est
        }
        if (!is.null(scaling.reference)) 
            hv <- emoa::dominated_hypervolume(points = t(scaling_Y(Y, 
                scaling.reference)), ref = ref.point)
        else hv <- emoa::dominated_hypervolume(points = t(Y), 
            ref = ref.point)
        if (!nullRF) 
            hv.front <- emoa::dominated_hypervolume(points = t(ref.front), 
                ref = ref.point)
        if (!nullRF) 
            hv.scaled <- hv/hv.front
    }
    if (!nullShowOutput) {
        cat("\nSummary of MOEA/D run")
        cat("\n#====================================")
        cat("\nTotal function evaluations: ", object$nfe)
        cat("\nTotal iterations: ", object$n.iter)
        cat("\nPopulation size: ", npts)
        cat("\nFeasible points found: ", nfeas, paste0("(", signif(100 * 
            nfeas/npts, 3), "%"), "of total)")
        cat("\nNondominated points found: ", nndom, paste0("(", 
            signif(100 * nndom/npts, 3), "%"), "of total)")
        cat("\nEstimated ideal point: ", round(ideal.est, ndigits))
        cat("\nEstimated nadir point: ", round(nadir.est, ndigits))
        if (!nullRF) 
            cat("\nEstimated IGD: ", igd)
        if ("emoa" %in% rownames(utils::installed.packages())) {
            cat("\nEstimated HV: ", hv)
            cat("\nEstimated HV (HV(Y)/HV(ref.front): ", hv.scaled)
            cat("\nRef point used for HV: ", ref.point)
        }
        else cat("\n\nPlease install package 'emoa' to calculate hypervolume.")
        cat("\n#====================================")
    }
    out <- list(hv.scaled = hv.scaled, hv = hv, igd = igd, nndom = nndom, 
        nfeas = nfeas)
    return(out)
}

[[52]]$visible
[1] FALSE


[[53]]
[[53]]$value
function (update, ...) 
{
    function_name <- paste0("updt_", tolower(update$name))
    updt.args <- as.list(sys.call())[-1]
    NextPop <- do.call(function_name, args = updt.args)
    if (updt.args$update$UseArchive) {
        arch.args <- updt.args
        arch.args$constraint$name <- "vbr"
        arch.args$constraint$type <- "ts"
        arch.args$update$name <- "best"
        arch.args$update$Tr <- nrow(arch.args$X)
        arch.args$update$nr <- nrow(arch.args$X)
        NextPop$Archive <- do.call("updt_restricted", args = arch.args)
    }
    else NextPop$Archive <- NULL
    return(NextPop)
}

[[53]]$visible
[1] FALSE


[[54]]
[[54]]$value
function (update, X, Xt, Y, Yt, V, Vt, normYs, W, BP, constraint, 
    aggfun, ...) 
{
    assertthat::assert_that(all(assertthat::has_name(update, 
        c("nr", "Tr"))), assertthat::is.count(update$nr), assertthat::is.count(update$Tr))
    nr <- update$nr
    Tr <- update$Tr
    fullZ <- scalarize_values(normYs = normYs, W = W, B = BP$fullB, 
        aggfun = aggfun)
    best.indx <- apply(X = fullZ[1:(nrow(fullZ) - 1), , drop = FALSE], 
        MARGIN = 1, FUN = which.min)
    best.subprob <- mapply(FUN = function(i, j, B) {
        B[i, j]
    }, i = 1:nrow(BP$fullB), j = best.indx, MoreArgs = list(B = BP$fullB))
    bestB <- BP$fullB[best.subprob, 1:Tr, drop = FALSE]
    bestZ <- scalarize_values(normYs = normYs, W = W, B = bestB, 
        aggfun = aggfun)
    best.sel.indx <- order_neighborhood(bigZ = bestZ, B = bestB, 
        V = V, Vt = Vt, constraint = constraint)
    do.update <- function(i, sel.indx, XY, XYt, B) {
        for (j in sel.indx[i, ]) {
            if (j > ncol(B)) 
                return(XYt[i, , drop = FALSE])
            else if (used[B[i, j]] < nr) {
                used[B[i, j]] <<- used[B[i, j]] + 1
                return(XY[B[i, j], , drop = FALSE])
            }
        }
    }
    I <- sample.int(nrow(X))
    I2 <- order(I)
    used <- rep(0, nrow(X))
    Xnext <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(X)), 
        sel.indx = best.sel.indx, XY = X, XYt = Xt, B = bestB, 
        USE.NAMES = FALSE))
    Xnext <- Xnext[I2, ]
    used <- rep(0, nrow(Y))
    Ynext <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(Y)), 
        sel.indx = best.sel.indx, XY = Y, XYt = Yt, B = bestB, 
        USE.NAMES = FALSE))
    Ynext <- Ynext[I2, ]
    if (is.null(V)) {
        Vnext <- NULL
    }
    else {
        Vnext <- list(Cmatrix = NULL, Vmatrix = NULL, v = NULL)
        used <- rep(0, nrow(Y))
        Vnext$Cmatrix <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(V$Cmatrix)), 
            sel.indx = best.sel.indx, XY = V$Cmatrix, XYt = Vt$Cmatrix, 
            B = bestB, USE.NAMES = FALSE))
        used <- rep(0, nrow(Y))
        Vnext$Vmatrix <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(V$Vmatrix)), 
            sel.indx = best.sel.indx, XY = V$Vmatrix, XYt = Vt$Vmatrix, 
            B = bestB, USE.NAMES = FALSE))
        Vnext$v <- rowSums(Vnext$Vmatrix)
    }
    return(list(X = Xnext, Y = Ynext, V = Vnext))
}

[[54]]$visible
[1] FALSE


[[55]]
[[55]]$value
function (update, X, Xt, Y, Yt, V, Vt, normYs, W, BP, constraint, 
    aggfun, B, ...) 
{
    fullZ <- scalarize_values(normYs = normYs, W = W, B = BP$fullB, 
        aggfun = aggfun)
    aux <- normYs
    aux$Y <- normYs$Yt
    fullZt <- scalarize_values(normYs = aux, W = W, B = BP$fullB, 
        aggfun = aggfun)
    best.indx <- apply(X = (fullZ[1:(nrow(fullZ) - 1), , drop = FALSE] - 
        fullZt[1:(nrow(fullZt) - 1), , drop = FALSE])/fullZ[1:(nrow(fullZ) - 
        1), , drop = FALSE], MARGIN = 1, FUN = which.min)
    best.subprob <- mapply(FUN = function(i, j, B) {
        B[i, j]
    }, i = 1:nrow(BP$fullB), j = best.indx, MoreArgs = list(B = BP$fullB))
    bestB <- BP$fullB
    bestZ <- scalarize_values(normYs = normYs, W = W, B = bestB, 
        aggfun = aggfun)
    best.sel.indx <- order_neighborhood(bigZ = bestZ, B = bestB, 
        V = V, Vt = Vt, constraint = constraint)
    do.update <- function(i, sel.indx, XY, XYt, B) {
        for (j in sel.indx[i, ]) {
            if (j > ncol(B)) 
                return(XYt[i, , drop = FALSE])
            else if (used[B[i, j]] < 1) {
                used[B[i, j]] <<- used[B[i, j]] + 1
                return(XY[B[i, j], , drop = FALSE])
            }
        }
    }
    I <- sample.int(nrow(X))
    I2 <- order(I)
    used <- rep(0, nrow(Y))
    Xnext <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(X)), 
        sel.indx = best.sel.indx, XY = X, XYt = Xt, B = B, USE.NAMES = FALSE))
    Xnext <- Xnext[I2, ]
    used <- rep(0, nrow(Y))
    Ynext <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(Y)), 
        sel.indx = best.sel.indx, XY = Y, XYt = Yt, B = B, USE.NAMES = FALSE))
    Ynext <- Ynext[I2, ]
    if (is.null(V)) {
        Vnext <- NULL
    }
    else {
        Vnext <- list(Cmatrix = NULL, Vmatrix = NULL, v = NULL)
        used <- rep(0, nrow(Y))
        Vnext$Cmatrix <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(V$Cmatrix)), 
            sel.indx = best.sel.indx, XY = V$Cmatrix, XYt = Vt$Cmatrix, 
            B = B, USE.NAMES = FALSE))
        used <- rep(0, nrow(Y))
        Vnext$Vmatrix <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(V$Vmatrix)), 
            sel.indx = best.sel.indx, XY = V$Vmatrix, XYt = Vt$Vmatrix, 
            B = B, USE.NAMES = FALSE))
        Vnext$v <- rowSums(Vnext$Vmatrix)
    }
    return(list(X = Xnext, Y = Ynext, V = Vnext))
}

[[55]]$visible
[1] FALSE


[[56]]
[[56]]$value
function (update, X, Xt, Y, Yt, V, Vt, sel.indx, B, ...) 
{
    assertthat::assert_that(assertthat::has_name(update, "nr"), 
        assertthat::is.count(update$nr))
    nr <- update$nr
    rest.sel.indx <- sel.indx
    do.update <- function(i, sel.indx, XY, XYt, B) {
        for (j in sel.indx[i, ]) {
            if (j > ncol(B)) 
                return(XYt[i, , drop = FALSE])
            else if (used[B[i, j]] < nr) {
                used[B[i, j]] <<- used[B[i, j]] + 1
                return(XY[B[i, j], , drop = FALSE])
            }
        }
    }
    I <- sample.int(nrow(X))
    I2 <- order(I)
    used <- rep(0, nrow(X))
    Xnext <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(X)), 
        sel.indx = rest.sel.indx, XY = X, XYt = Xt, B = B, USE.NAMES = FALSE))
    Xnext <- Xnext[I2, ]
    used <- rep(0, nrow(Y))
    Ynext <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(Y)), 
        sel.indx = rest.sel.indx, XY = Y, XYt = Yt, B = B, USE.NAMES = FALSE))
    Ynext <- Ynext[I2, ]
    if (is.null(V)) {
        Vnext <- NULL
    }
    else {
        Vnext <- list(Cmatrix = NULL, Vmatrix = NULL, v = NULL)
        used <- rep(0, nrow(Y))
        Vnext$Cmatrix <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(V$Cmatrix)), 
            sel.indx = rest.sel.indx, XY = V$Cmatrix, XYt = Vt$Cmatrix, 
            B = B, USE.NAMES = FALSE))
        used <- rep(0, nrow(Y))
        Vnext$Vmatrix <- t(vapply(X = I, FUN = do.update, FUN.VALUE = numeric(ncol(V$Vmatrix)), 
            sel.indx = rest.sel.indx, XY = V$Vmatrix, XYt = Vt$Vmatrix, 
            B = B, USE.NAMES = FALSE))
        Vnext$v <- rowSums(Vnext$Vmatrix)
    }
    return(list(X = Xnext, Y = Ynext, V = Vnext))
}

[[56]]$visible
[1] FALSE


[[57]]
[[57]]$value
function (X, Xt, Y, Yt, V, Vt, sel.indx, B, ...) 
{
    std.sel.indx <- sel.indx[, 1]
    do.update <- function(i, sel.indx, XY, XYt, B) {
        if (sel.indx[i] > ncol(B)) 
            return(XYt[i, ])
        else return(XY[B[i, sel.indx[i]], ])
    }
    Xnext <- t(vapply(X = 1:nrow(X), FUN = do.update, FUN.VALUE = numeric(ncol(X)), 
        sel.indx = std.sel.indx, XY = X, XYt = Xt, B = B, USE.NAMES = FALSE))
    Ynext <- t(vapply(X = 1:nrow(Y), FUN = do.update, FUN.VALUE = numeric(ncol(Y)), 
        sel.indx = std.sel.indx, XY = Y, XYt = Yt, B = B, USE.NAMES = FALSE))
    if (is.null(V)) {
        Vnext <- NULL
    }
    else {
        Vnext <- list(Cmatrix = NULL, Vmatrix = NULL, v = NULL)
        Vnext$Cmatrix <- t(vapply(X = 1:nrow(V$Cmatrix), FUN = do.update, 
            FUN.VALUE = numeric(ncol(V$Cmatrix)), sel.indx = std.sel.indx, 
            XY = V$Cmatrix, XYt = Vt$Cmatrix, B = B, USE.NAMES = FALSE))
        Vnext$Vmatrix <- t(vapply(X = 1:nrow(V$Vmatrix), FUN = do.update, 
            FUN.VALUE = numeric(ncol(V$Vmatrix)), sel.indx = std.sel.indx, 
            XY = V$Vmatrix, XYt = Vt$Vmatrix, B = B, USE.NAMES = FALSE))
        Vnext$v <- rowSums(Vnext$Vmatrix)
    }
    return(list(X = Xnext, Y = Ynext, V = Vnext))
}

[[57]]$visible
[1] FALSE


[[58]]
[[58]]$value
function (Y, X) 
{
    minP <- getminP(rbind(Y, X))
    maxP <- getmaxP(rbind(Y, X))
    MinP <- matrix(rep(minP, times = nrow(Y)), nrow = nrow(Y), 
        byrow = TRUE)
    MaxP <- matrix(rep(maxP, times = nrow(Y)), nrow = nrow(Y), 
        byrow = TRUE)
    Y <- (Y - MinP)/(MaxP - MinP + 1e-16)
    return(Y)
}

[[58]]$visible
[1] FALSE


[[59]]
[[59]]$value
function (X, Xt, rho, ...) 
{
    assertthat::assert_that(is.numeric(X) && is.matrix(X), is.numeric(Xt) && 
        is.matrix(Xt), identical(dim(X), dim(Xt)), is.numeric(rho) && 
        is_within(rho, 0, 1, strict = FALSE))
    R <- randM(X) < rho
    K <- matrix(FALSE, nrow(X), ncol(X))
    for (i in 1:nrow(X)) {
        K[i, sample(ncol(X), size = 1)] <- TRUE
    }
    R <- R | (rowSums(R) == 0 & K)
    return(R * X + (!R) * Xt)
}

[[59]]$visible
[1] FALSE


[[60]]
[[60]]$value
function (X, P, phi = 0.5, ...) 
{
    phi <- 0.5
    new.solution <- X
    dimX <- dim(X)[1]
    for (i in 1:dim(X)[1]) {
        idx <- sample.int(dimX, 3, replace = TRUE, prob = P[, 
            i])
        new.solution[i, ] <- X[idx[1], ] + phi * (X[idx[2], ] - 
            X[idx[3], ])
    }
    return(new.solution)
}

[[60]]$visible
[1] FALSE


[[61]]
[[61]]$value
function (X, P, B, Phi = NULL, basis = "rand", ...) 
{
    input.pars <- as.list(sys.call())[-1]
    assertthat::assert_that(is.numeric(X) && is.matrix(X), is.numeric(P) && 
        is.matrix(P) && is_within(P, 0, 1, strict = FALSE), identical(nrow(X), 
        nrow(P)), nrow(P) == ncol(P), is.numeric(B) && is.matrix(B), 
        nrow(B) == nrow(X), is.null(Phi) || (is.numeric(Phi) && 
            Phi != 0), is.element(basis, c("rand", "mean", "wgi")))
    dimX <- dim(X)
    R <- t(sapply(1:dimX[1], FUN = function(i) {
        sample.int(dimX[1], size = 3, replace = FALSE, prob = P[, 
            i])
    }))
    if (is.null(Phi)) {
        Phi <- matrix(stats::runif(dimX[1]), nrow = dimX[1], 
            ncol = dimX[2], byrow = FALSE)
    }
    if (basis == "rand") {
        Xb <- X[R[, 1], , drop = FALSE]
    }
    else if (basis == "mean") {
        Xb <- t(sapply(1:nrow(X), FUN = function(i) {
            apply(X[B[i, , drop = FALSE], ], MARGIN = 2, FUN = mean)
        }))
    }
    else if (basis == "wgi") {
        normYs <- scale_objectives(Y = input.pars$Y, Yt = input.pars$Yt, 
            scaling = input.pars$scaling)
        bigZ <- scalarize_values(normYs = normYs, W = input.pars$W, 
            B = B, aggfun = input.pars$aggfun)
        bigZ <- t(bigZ[-nrow(bigZ), , drop = FALSE])
        wgi.W <- log(ncol(bigZ) + 0.5) - log(1:ncol(bigZ))
        Xb <- t(sapply(1:dimX[1], FUN = function(i) {
            indx <- order(bigZ[i, , drop = FALSE])
            colSums(wgi.W * X[B[i, indx, drop = FALSE], ])
        }))
    }
    return(Xb + Phi * (X[R[, 2], , drop = FALSE] - X[R[, 3], 
        , drop = FALSE]))
}

[[61]]$visible
[1] FALSE


[[62]]
[[62]]$value
function (...) 
{
    vls.input.pars <- as.list(sys.call())[-1]
    opname <- paste0("ls_", vls.input.pars$ls.args$type)
    Xls <- do.call(opname, args = vls.input.pars)
    if (vls.input.pars$ls.args$trunc.x) {
        if (is.matrix(Xls)) {
            Xls <- matrix(pmax(0, pmin(Xls, 1)), nrow = nrow(Xls), 
                byrow = FALSE)
        }
        else {
            Xls$X <- matrix(pmax(0, pmin(Xls$X, 1)), nrow = nrow(Xls$X), 
                byrow = FALSE)
        }
    }
    return(Xls)
}

[[62]]$visible
[1] FALSE


[[63]]
[[63]]$value
function (X, ...) 
{
    return(X)
}

[[63]]$visible
[1] FALSE


[[64]]
[[64]]$value
function (X, eta) 
{
    r <- randM(X)
    myflag <- (r <= 0.5)
    mexp <- 1/(eta + 1)
    Deltaq <- myflag * ((2 * r + (1 - 2 * r) * (1 - X)^(eta + 
        1))^mexp - 1) + (!myflag) * (1 - (2 * (1 - r) + 2 * (r - 
        0.5) * X^(eta + 1))^mexp)
    return(Deltaq)
}

[[64]]$visible
[1] FALSE


[[65]]
[[65]]$value
function (Beta, Eta) 
{
    r <- randM(Beta)
    alpha <- 2 - Beta^-(Eta + 1)
    myflag <- (r <= 1/alpha)
    Betaq <- ((r * alpha)^(1/(Eta + 1))) * myflag + (2 - r * 
        alpha)^-(1/(Eta + 1)) * (!myflag)
    return(Betaq)
}

[[65]]$visible
[1] FALSE


[[66]]
[[66]]$value
function (X, ...) 
{
    X <- matrix(pmax(0, pmin(X, 1)), nrow = nrow(X), byrow = FALSE)
    return(X)
}

[[66]]$visible
[1] FALSE


[[67]]
[[67]]$value
function (name, j) 
{
    curDir <- getwd()
    setwd("~/MOEADr/R/")
    X <- read_feather(paste0("../dataExp/", name, j, "_X"))
    Y <- read_feather(paste0("../dataExp/", name, j, "_Y"))
    plot.paretofront <- read_feather(paste0("../dataExp/", name, 
        j, "_plot.paretofront"))
    plot.resources <- read_feather(paste0("../dataExp/", name, 
        j, "_plot.resources"))
    plot.paretoset <- read_feather(paste0("../dataExp/", name, 
        j, "_plot.paretoset"))
    iter <- read_feather(paste0("../dataExp/", name, j, "_iter"))
    time <- read_feather(paste0("../dataExp/", name, j, "_time"))
    W <- read_feather(paste0("../dataExp/", name, j, "_W"))
    nfe <- read_feather(paste0("../dataExp/", name, j, "_nfe"))
    out <- list(X = X, Y = Y, W = W, nfe = nfe, n.iter = iter, 
        time = time, plot.paretofront = plot.paretofront, plot.paretoset = plot.paretoset, 
        plot.resources = plot.resources, moead.norm = FALSE)
    return(out)
    setwd(curDir)
}

[[67]]$visible
[1] FALSE


            Group.1        x
1           de.data 1.207674
2         norm.data 1.209769
3 norm.inverse.data 1.207232
4   norm.tournament 1.209313
            Group.1        x
1           de.data 99.94147
2         norm.data 50.54472
3 norm.inverse.data 96.18096
4   norm.tournament 95.06325
Error in normalizePath(path, mustWork = TRUE) : 
  path[1]="../dataExp/DTLZ2_moead.de21_X": No such file or directory
Calls: loadPlotData -> read_feather -> feather -> normalizePath
Execution halted
